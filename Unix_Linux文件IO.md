# Unix/Linux IO编程

#### 程序对文件进行读写操作前，需要在程序与文件之间建立连接或通信通道，这个过程叫做打开文件。在Unix/Linux系统下，有两种机制实现这一过程，即文件描述字和流。当使用文件描述字或流的IO函数打开一个文件时，它们会分别返回一个流或一个文件描述字，使用这个文件描述字或流可以对文件进行相应的读写操作。

#### 操作流或者文件描述字的函数是不一样的，所以系统中关于IO函数可以分为两大类：一类针对流操作，一类针对文件描述字操作。

#### 流的IO函数是建立在对文件描述字的操作上实现的，它给程序提供了更高一级的输入输出接口。下面将介绍的标准输入输出是针对流操作的，而低级输入输出部分将探讨文件描述字的IO函数。

#### 标准流：UNIX系统中每个进程都有三个预先定义的并自动打开的流，即stdin、stdout、stderr，分别代表标准输入，标准输出、标准错误输出

## 标准输入输出

> 打开与关闭文件：

- FILE* fopen(); 打开成功，返回流指针，否则返回NULL
- FILE* fclose(); 关闭成功返回0，否则返回EOF并置errno指明错误
- FILE* freopen(); 打开成功，返回流指针，否则返回NULL并置errno指明错误

> 读写流： 字符IO/行IO/块IO

**字符IO：**

- int fgetc(); 按unsigned int类型读取下一个字符，并强制转化为int类型，若遇到文件结束或错误则返回EOF
- int getc(); 与fgetc相同，但getc是以宏来实现的
- int getchar(); 等价于getc(stdin) 

- int fputc(); 将字符转化为unsigned char类型，再写至流中
- int putc(); 与fputc相同，但getc是以宏来实现的
- int putchar(); 等价于putc(stdout)

**行IO：**

- char* fgets(char* s, int count, FILE* stream); 从流中读取字符，直至读到换行符或者读够count-1个字符（包括换行符），读取的字符存放在字符串s中，并且自动在s的末尾添加空字符（\0），参数count指明字符串s的大小。总之，读取完后，字符串总是会以空字符结尾。
- char* gets(char* s); 从stdin中读入完整的一行字串存放在字串s中，它删除换行符，并添加一个空字符在末尾。gets函数容易导致字符串s的溢出，因为它没有考虑字串s的空间大小，且在溢出时也不会提供保护。
- ssize_t getline(); 读取一行（包括换行符和一个终止字符），返回值为读入的字符数（包括换行符，但不包括空字符）
- ssize_t getdelim(); 自定义终止字符，getline即由getdelim实现

- int fputs(); 输出以空字符结尾的字符串s至流中，但结尾的空字符不写入，也不添加换行符，发生错误返回EOF，否则返回一个非负值。
- int puts(); 输出一个以空字符结尾的字串s至标准输出流中，并添加一个换行符

**块IO（二进制IO）：**

> 块IO是按数据的原始形态，即二进制格式读写的。按二进制格式读写数据的效率常常比使用其他形式的IO要好，特别是浮点型数据，避免了转换处理时精度的丢失。

- size_t fread();
- size_t fwrite();

> 文件定位

- long int ftell(); 成功则返回文件当前位置（从文件开始的字节数），否则返回-1并置errno
- int fseek(); 改变文件当前位置
- void rewind(); 返回文件开始的位置
- int fgetpos(); 返回当前位置并存储在指定的结构体中
- int fsetpos(); 使用指定的结构体对象设置当前的位置

> 格式输入与输出（用于字符流而非二进制流）

- printf();	输出至标准输出
- fprintf(); 输出至指定流中
- sprintf(); 输出至指定的字符数组中，并在末尾自动添加一个空字符

- scanf(); 输入自标准输出
- fscanf(); 输入自指定流
- sscanf(); 输入自指定的字符数组

## 低级输入输出

