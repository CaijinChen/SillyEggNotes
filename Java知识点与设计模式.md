# Java知识点与设计模式
---
### 【整理自[菜鸟教程](http://www.runoob.com)与gitbook《[设计模式Java版](https://gof.quanke.name/)》（刘伟）】

### 忠告：适合对Java有一定了解的人阅读

## 一、Java知识点

### Java关键字
<table>
	<thead>
		<th>类别</th>
		<th>关键字</th>
		<th>说明</th>
	</thead>
	<tbody>
		<tr>
			<td rowspan="3">访问控制</td>
			<td>private</td>		
			<td>私有的</td>
		</tr>
		<tr>
			<td>protected</td>		
			<td>受保护的</td>
		</tr>
		<tr>
			<td>public</td>		
			<td>公共的</td>
		</tr>
		<tr>
			<td rowspan="13">类、方法和变量修饰符</td>
			<td>abstract</td>		
			<td>声明抽象</td>
		</tr>
		<tr>
			<td>class</td>		
			<td>类</td>
		</tr>
		<tr>
			<td>extends</td>		
			<td>扩充,继承</td>
		</tr>
		<tr>
			<td>final</td>		
			<td>最终值,不可改变的</td>
		</tr>
		<tr>
			<td>implements</td>		
			<td>实现（接口）</td>
		</tr>
		<tr>
			<td>interface</td>		
			<td>接口</td>
		</tr>
		<tr>
			<td>native</td>		
			<td>本地，原生方法（非Java实现）</td>
		</tr>
		<tr>
			<td>new</td>		
			<td>新,创建</td>
		</tr>
		<tr>
			<td>static</td>		
			<td>静态</td>
		</tr>
		<tr>
			<td>strictfp</td>		
			<td>严格,精准</td>
		</tr>
		<tr>
			<td>synchronized</td>		
			<td>线程,同步</td>
		</tr>
		<tr>
			<td>transient</td>		
			<td>短暂</td>
		</tr>
		<tr>
			<td>volatile</td>		
			<td>易失</td>
		</tr>
		<tr>
			<td rowspan="2">程序控制语句</td>
			<td>break、case、continue、default、do、else、for、if、return、switch、while</td>	
			<td>常用</td>
		</tr>
		<tr>
			<td>instanceof</td>		
			<td>实例</td>
		</tr>
		<tr>
			<td>错误处理</td>
			<td>assert、finally、catch、throw、throws、try</td>	
			<td>常用，throws【声明一个异常可能被抛出】，assert【断言表达式是否为真】</td>
		</tr>
		<tr>
			<td>包相关</td>
			<td>import、package</td>	
			<td>常用</td>
		</tr>
		<tr>
			<td>基本类型</td>
			<td>boolean、byte、char、double、float、int、long、short</td>	
			<td>常用</td>
		</tr>
		<tr>
			<td rowspan="3">变量引用</td>
			<td>super</td>	
			<td>父类,超类</td>
		</tr>
		<tr>
			<td>this</td>	
			<td>本类</td>
		</tr>
		<tr>
			<td>void</td>	
			<td>无返回值</td>
		</tr>
		<tr>
			<td rowspan="3">保留关键字</td>
			<td>goto</td>	
			<td>是关键字，但不能使用</td>
		</tr>
		<tr>
			<td>const</td>	
			<td>是关键字，但不能使用</td>
		</tr>
		<tr>
			<td>null</td>	
			<td>空</td>
		</tr>
	</tbody>
</table>

---

### 源文件声明规则

- 一个源文件中只能有一个public类
- 一个源文件可以有多个非public类
- 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。
- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。
- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。
- import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。

---

### 数据类型

####1.值类型

- byte：
	- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
	- 最小值是 -128（-2^7）；
	- 最大值是 127（2^7-1）；
	- 默认值是 0；
	- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
	- 例子：byte a = 100，byte b = -50。
- short：
	- short 数据类型是 16 位、有符号的以二进制补码表示的整数
	- 最小值是 -32768（-2^15）；
	- 最大值是 32767（2^15 1）；
	- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
	- 默认值是 0；
	- 例子：short s = 1000，short r = -20000。
- int：
	- int 数据类型是32位、有符号的以二进制补码表示的整数；
	- 最小值是 -2,147,483,648（-2^31）；
	- 最大值是 2,147,483,647（2^31 1）；
	- 一般地整型变量默认为 int 类型；
	- 默认值是 0 ；
	- 例子：int a = 100000, int b = -200000。
- long：
	- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
	- 最小值是 -9,223,372,036,854,775,808（-2^63）；
	- 最大值是 9,223,372,036,854,775,807（2^63 -1）；
	- 这种类型主要使用在需要比较大整数的系统上；
	- 默认值是 0L；
	- 例子： long a = 100000L，Long b = -200000L。
	- "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。
- float：
	- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
	- float 在储存大型浮点数组的时候可节省内存空间；
	- 默认值是 0.0f；
	- 浮点数不能用来表示精确的值，如货币；
	- 例子：float f1 = 234.5f。
- double：
	- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
	- 浮点数的默认类型为double类型；
	- double类型同样不能表示精确的值，如货币；
	- 默认值是 0.0d；
	- 例子：double d1 = 123.4。
- boolean：
	- boolean数据类型表示一位的信息；
	- 只有两个取值：true 和 false；
	- 这种类型只作为一种标志来记录 true/false 情况；
	- 默认值是 false；
	- 例子：boolean one = true。
- char：
	- char类型是一个单一的 16 位 Unicode 字符；
	- 最小值是 \u0000（即为0）；
	- 最大值是 \uffff（即为65,535）；
	- char 数据类型可以储存任何字符；
	- 例子：char letter = 'A';。
- **实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作**

#### 2.引用类型（与指针类似）

- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。

---

### 类型转换规则

1. 不能对boolean类型进行类型转换。

2. 不能把对象类型转换成不相关类的对象。

3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

4. 转换过程中可能导致溢出或失精度

5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入

6. 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型

---

### 变量

- 局部变量
	1. 局部变量声明在方法、构造方法或者语句块中；
	1. 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
	1. 访问修饰符不能用于局部变量；
	1. 局部变量只在声明它的方法、构造方法或者语句块中可见；
	1. 局部变量是在栈上分配的。
	1. 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 
- 实例变量
	1. 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
	1. 当一个对象被实例化之后，每个实例变量的值就跟着确定；
	1. 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
	1. 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
	1. 实例变量可以声明在使用前或者使用后；
	1. 访问修饰符可以修饰实例变量；
	1. 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
	1. 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
	1. 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。
- 类变量
	1. 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。
	1. 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
	1. 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
	1. 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
	1. 静态变量在第一次被访问时创建，在程序结束时销毁。
	1. 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
	1. 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
	1. 静态变量可以通过：ClassName.VariableName的方式访问。
	1. 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。

---

### 访问控制修饰符
 
1. default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

1. private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类，内部类可以）

1. public : 对所有类可见。使用对象：类、接口、变量、方法
 
1. protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类，内部类可以）。

**注意**

- 父类中声明为 public 的方法在子类中也必须为 public。
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被继承。

### 非访问控制修饰符

- static 修饰符，用来修饰类方法和类变量。

- final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的
	- final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。final 修饰符通常和 static 修饰符一起使用来创建类常量。
	- 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。
	- final 类不能被继承，没有类能够继承 final 类的任何特性。
- abstract 修饰符，用来创建抽象类（抽象类可以包含抽象方法和非抽象方法）和抽象方法。

- synchronized 和 volatile 修饰符，主要用于线程的编程。
	- synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符（public、protected、private、default）。
	- volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
- transient 修饰符
	- 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

---

### 控制语句

- break/continue [label]; 规定标号label必需放在循环之前（意味着循环必需紧跟着标号）
- switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。

---

### 包装类

- Java 会对 -128 ~ 127 的整数进行缓存，所以当定义两个包装类变量初始化值位于 -128 ~ 127 之间时，两个变量使用了同一地址

		Long l1 = 128l;
        Long l2 = 128l;
        System.out.println(l1 == l2);//false！！！
        
        Long l1 = 1l;
        Long l2 = 1l;
        System.out.println(l1 == l2);//true！！！
- 注意 == 与 equals的区别： “==” 它比较的是对象的地址，“equals” 比较的是对象的内容

---

### 继承

- 子类拥有父类非private的属性，方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。
- 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口
- super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
- this关键字：指向自己的引用。
- **如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表，如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。**

### 多态

- 重载与重写

	|区别点|重载方法|重写方法|
	|:-|:-|:-|
	|参数列表|必须修改|一定不能修改|
	|返回类型|可以修改|一定不能修改|
	|异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常|
	|访问|可以修改|一定不能做更严格的限制（可以降低限制）|

### 抽象

- **构造方法，类方法（用static修饰的方法）不能声明为抽象方法**

### 封装

1. 良好的封装能够减少耦合。

2. 类内部的结构可以自由修改。

3. 可以对成员变量进行更精确的控制。

4. 隐藏信息，实现细节。

### 接口

##### 接口与类相似点：

- 一个接口可以有多个方法。
- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在 .class 结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。
##### 接口与类的区别：

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

#### 接口特性

- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

### Java集合框架

![](https://i.imgur.com/91G8iWV.png)

> 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。

![](https://i.imgur.com/QlKALV1.png)

> 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
- 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。
- 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

##### 一些接口

![](https://i.imgur.com/q3X7IpM.png)

**Set和List的区别：**

1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。

2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <实现类有HashSet,TreeSet>。

3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <实现类有ArrayList,LinkedList,Vector> 。

#### 抽象类和接口的区别

- 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
- 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

#### 一些实现

1. AbstractCollection 
实现了大部分的集合接口。
2. AbstractList 
继承于AbstractCollection 并且实现了大部分List接口。
3. AbstractSequentialList 
继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。
4. LinkedList
该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：

		Listlist=Collections.synchronizedList(newLinkedList(...));
		LinkedList 查找效率低。

5. ArrayList
该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。

6. AbstractSet 
继承于AbstractCollection 并且实现了大部分Set接口。
7. HashSet
该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。

8. LinkedHashSet
具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。
9. TreeSet
该类实现了Set接口，可以实现排序等功能。

10. AbstractMap 
实现了大部分的Map接口。
11. HashMap 
HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。
12. TreeMap 
继承了AbstractMap，并且使用一颗树。
13. WeakHashMap 
继承AbstractMap类，使用弱密钥的哈希表。
14. LinkedHashMap 
继承于HashMap，使用元素的自然顺序对元素进行排序.
15. IdentityHashMap 
继承AbstractMap类，比较文档时使用引用相等。

**何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。**

### 泛型

#### 定义泛型方法的规则：

1. 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。
1. 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
1. 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
1. 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）

		// 泛型方法 printArray                         public static < E > void printArray( E[] inputArray ){
	      // 输出数组元素            
	         for ( E element : inputArray ){        
	            System.out.printf( "%s ", element );
	         }
	         System.out.println();
	    }
		//有界的类型参数:
		//可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。
		//要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。
		public static <T extends Comparable<T>> T maximum(T x, T y, T z)
		{                     
		  T max = x; // 假设x是初始最大值
		  if ( y.compareTo( max ) > 0 ){
		     max = y; //y 更大
		  }
		  if ( z.compareTo( max ) > 0 ){
		     max = z; // 现在 z 更大           
		  }
		  return max; // 返回最大对象
		}

#### 泛型类

	public class Box<T> {
	   
	  private T t;
	 
	  public void add(T t) {
	    this.t = t;
	  }
	 
	  public T get() {
	    return t;
	  }
	}

#### 类型通配符
1. 型通配符一般是使用?代替具体的类型参数。例如 List<?> 在逻辑上是List<String>,List<Integer> 等所有List<具体类型实参>的父类。
2. 类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。

		public static void getData(List<? extends Number> data) {
		}
3、类型通配符下限通过形如 List<? super Number>来定义，表示类型只能接受Number及其上层父类类型，如Objec类型的实例。

### Java序列化

一个类的对象要想序列化成功，必须满足两个条件：

1. 该类必须实现 java.io.Serializable 对象。

2. 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（**transient**）。如果想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。

##### ObjectOutputStream 类用来序列化一个对象
##### ObjectInputStream 类用来反序列化一个对象

### 网络编程

1. BIO 编程

> Blocking IO： 同步阻塞的编程方式。

> BIO编程方式通常是在JDK1.4版本之前常用的编程方式。编程实现过程为：首先在服务端启动一个ServerSocket来监听网络请求，客户端启动Socket发起网络请求，默认情况下ServerSocket回建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。

> 且建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。大致结构如下：

> 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

> BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

2. NIO 编程：Unblocking IO（New IO）： 同步非阻塞的编程方式。

> NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题，NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。

> NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。

> 在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题

3. AIO编程：Asynchronous IO： 
4. 非阻塞的编程方式。

> 与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：AsynchronousSocketChannel、AsynchronousServerSocketChannel、AsynchronousFileChannel、AsynchronousDatagramChanne

### 多线程

![](https://i.imgur.com/YSsuaqz.png)

1. **新建状态**:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
 
1. **就绪状态**:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

1. **运行状态**:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
 
1. **阻塞状态**:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：

	- 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
	
	- 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
	
	- 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

1. **死亡状态**:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

##### 优先级

> Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。
#
> 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。
#
> 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。

##### 创建

Java 提供了三种创建线程的方法：

- 通过实现 Runnable 接口；
- 通过继承 Thread 类本身；
- 通过 Callable 和 Future 创建线程。

##### 线程Threa类的一些方法

- 实例方法
![](https://i.imgur.com/VdvnSWN.png)
- 静态方法
![](https://i.imgur.com/xCbsQqU.png)

##### 通过 Callable 和 Future 创建线程

1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。

2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。

3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。

4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值

		public class CallableThreadTest implements Callable<Integer> {
		public static void main(String[] args)  
		{  
		    CallableThreadTest ctt = new CallableThreadTest();  
		    FutureTask<Integer> ft = new FutureTask<>(ctt);  
		    for(int i = 0;i < 100;i++)  
		    {  
		        System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i);  
		        if(i==20)  
		        {  
		            new Thread(ft,"有返回值的线程").start();  
		        }  
		    }  
		    try  
		    {  
		        System.out.println("子线程的返回值："+ft.get());  
		    } catch (InterruptedException e)  
		    {  
		        e.printStackTrace();  
		    } catch (ExecutionException e)  
		    {  
		        e.printStackTrace();  
		    }  
		
		}
		@Override  
		public Integer call() throws Exception  
		{  
		    int i = 0;  
		    for(;i<100;i++)  
		    {  
		        System.out.println(Thread.currentThread().getName()+" "+i);  
		    }  
		    return i;  
		}  
		}

##### 创建线程的三种方式的对比
1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。

2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。

##### 一些概念

- 线程同步
- 线程间通信
- 线程死锁
- 线程控制：挂起、停止和恢复

##### 多线程的使用

> 有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。
#
> 通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。
#
> 请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！

### Java Doc格式

> Java 支持三种注释方式。前两种分别是 // 和 /* */，第三种被称作说明注释，它以 /\*\* 开始，以 */结束。
#
> 说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。
#
> 说明注释，使你更加方便的记录你的程序信息。

##### javadoc工具可识别的标签

标签|描述|示例
:-|:-|:-
@author|标识一个类的作者|@author description
@deprecated|指名一个过期的类或成员	|@deprecated description
{@docRoot}|指明当前文档根目录的路径|Directory Path
@exception|标志一个类抛出的异常|@exception exception-name explanation
{@inheritDoc}|从直接父类继承的注释|Inherits a comment from the immediate surperclass.
{@link}|插入一个到另一个主题的链接|{@link name text}
{@linkplain}|插入一个到另一个主题的链接，但是该链接显示纯文本字体|Inserts an in-line link to another topic.
@param|说明一个方法的参数|@param parameter-name explanation
@return|说明返回值类型|@return explanation
@see|指定一个到另一个主题的链接|@see anchor
@serial|说明一个序列化属性|@serial description
@serialData|说明通过writeObject( ) 和 writeExternal( )方法写的数据|@serialData description
@serialField|说明一个ObjectStreamField组件|@serialField name type description
@since|标记当引入一个特定的变化时|@since release
@throws|和 @exception标签一样.|The @throws tag has the same meaning as the @exception tag.
{@value}|显示常量的值，该常量必须是static属性。|Displays the value of a constant, which must be a static field.
@version|指定类的版本|	@version info

**自定义标签？**

---

### 其他知识点

- StringBuilder 与 StringBuffer，处理字符串的速度上前者优于后者，但StringBuilder线程不安全，多线程环境下应使用StringBuffer
- 使用 SimpleDateFormat 格式化日期

		SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss")

- [printf方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头](http://www.runoob.com/java/java-date-time.html)
- 传入可变参数，在方法声明中，在指定参数类型后加一个省略号(...) ，一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明：public static void printMax( double... numbers){}
- Java 允许定义finalize()，它在对象被垃圾收集器析构(回收)之前调用，它可以用来用来清除回收对象
- Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。Error 用来指示运行时环境发生的错误。
![](https://i.imgur.com/UHupPXL.png)
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法；子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
- **通过序列化实现深克隆**
- Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等

---

## 二、设计模式（将介绍24种，GoF 23种，比GoF多了一种简单工厂模式）

> 根据模式的用途，设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责

#### 设计原则

设计原则名称|定 义|使用频率
:-|:-|:-
单一职责原则 (Single Responsibility Principle, SRP)|一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因|★★★★☆
开闭原则 (Open-Closed Principle, OCP)|一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展|★★★★★
里氏代换原则(Liskov SubstitutionPrinciple, LSP)|所有引用基类对象的地方能够透明地使用其子类的对象，即在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立|★★★★★
依赖倒转原则 (Dependence InversionPrinciple, DIP)|抽象不应该依赖于细节，细节应该依赖于抽象，换言之，要针对接口编程，而不是针对实现编程|★★★★★
接口隔离原则(Interface SegregationPrinciple, ISP)|使用多个专门的接口，而不使用单一的总接口|★★☆☆☆
合成复用原则 (Composite ReusePrinciple, CRP)|尽量使用对象组合，而不是继承来达到复用的目的|★★★★☆
迪米特法则 (Law of Demeter, LoD)|一个软件实体应当尽可能少地与其他实体发生相互作用|★★★☆☆

#### 6种创建型模式

##### 单例模式 Singleton Pattern（违背了单一职责原则）

> 定义
#
- 在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一Singleton类型的静态对象，作为外部共享的唯一
实例
#
> 要点
#
- 一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。使用IoDH技术可以避免上述问题

		//Initialization on Demand Holder
		class Singleton {
		private Singleton() {
		}
		private static class HolderClass {
		private final static Singleton instance = new Singleton();
		}
		public static Singleton getInstance() {
		return HolderClass.instance;
		}
		public static void main(String args[]) {
		Singleton s1, s2;
		s1 = Singleton.getInstance();
		s2 = Singleton.getInstance();
		System.out.println(s1==s2);
		}
		}
		//由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次
		//调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，
		//此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。
		//由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。

#
> 示例
#
![](https://i.imgur.com/izPkSM2.png)

##### 简单工厂模式 Simple Factory Pattern（违背开闭原则）

> 定义
#
- 简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式
#
> 要点
#
- 当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计
#
> 示例
#
![](https://i.imgur.com/oaw8Nsy.png)

##### 工厂方法模式 Factory Method Pattern

> 定义
# 
- 定义一个用于创建对象的接口，让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类，又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。
#
> 总结
#
- 工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式
#
> 示例
#
![](https://i.imgur.com/DbvUEvi.png)

##### 抽象工厂模式 Abstract Factory Pattern（违背开闭原则）

> 定义
#
- 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。
#
> 缺点
#
- 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”
#
> 示例
#
![](https://i.imgur.com/YpBD3Zm.png)

##### 原型模式 Prototype Pattern（违背开闭原则）

> 定义
#
- 将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现
#
> 要点
#
-  需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”； 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作； 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦

##### 建造者模式 Builder Pattern

> 定义
#
- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式
#
> 要点
#
- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制；如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本
#
> 示例
#
![](https://i.imgur.com/KZaHW7k.png)

#### 7种结构性模式

##### 适配器模式 Adapter Pattern

> 定义
#
- 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。（**类适配器、对象适配器、双向适配器、缺省适配器**）
#
> 要点
#
- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构
#
> 示例(对象适配器)
#
![](https://i.imgur.com/GDZaPWE.png)

##### 桥接模式 Bridge Pattern

> 定义
#
- 将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式
#
> 要点
#
- 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”
#
> 示例
#
![](https://i.imgur.com/uNZpfge.png)

##### 组合模式 Composite Pattern

> 定义
#
- 组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致
性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式
#
> 要点
#
- 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单
#
> 示例
#
![](https://i.imgur.com/pnmausA.png)
##### 装饰模式 Decorator Pattern

> 定义
#
- 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式
#
> 要点
#
- 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加；具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装
饰类，原有类库代码无须改变，符合“开闭原则”。装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐
#
> 示例
#
![](https://i.imgur.com/MOO5XUq.png)
##### 外观模式 Facade Pattern

> 定义
#
- 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
#
> 要点
#
- 外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度
#
> 示例
#
![](https://i.imgur.com/gEUHtNk.png)
##### 享元模式 Flyweight Pattern

> 定义
#
- 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种
对象结构型模式
#
> 要点
#
- 享元模式可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享
#
> 示例
#
![](https://i.imgur.com/KxA5wrw.png)
##### 代理模式 Proxy Pattern

> 定义
#
- 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。
#
> 要点
#
- 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度.客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性
#
> 示例
#
![](https://i.imgur.com/2kXMTgt.png)

#### 11种行为型模式

##### 职责链模式 Chain of Responsibility Pattern

> 定义
#
- 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传
递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式
#
> 要点
#
- 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。如果建链不当，可能会造成循环调用，将导致系统陷入死循环
#
> 示例
#
![](https://i.imgur.com/RmdcNMF.png)
##### 命令模式 Command Pattern

> 定义
#
- 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式
#
> 要点
#
- 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求
#
> 示例
#
![](https://i.imgur.com/DyK1vYV.png)
##### 解释器模式 Interpreter Pattern

> 定义
#
- 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式
#
> 要点
#
- 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦
#
> 示例
#
![](https://i.imgur.com/tL8h6og.png)
##### 迭代器模式 Iterator Pattern

> 定义
#
- 提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式
#
> 要点
#
-  它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求
#
> 示例
#
![](https://i.imgur.com/IpzmFWw.png)
##### 中介者模式 Mediator Pattern

> 定义
#
- 用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式
#
> 要点
#
- 中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护
#
> 示例
#
![](https://i.imgur.com/MAZrasz.png)
##### 备忘录模式 Memento Pattern

> 定义
#
- 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计
#
> 要点
#
- 备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，当前很多软件都提供了撤销(Undo)操作，其中就使用了备忘录模式
#
> 示例
#
![](https://i.imgur.com/4y770zM.png)
##### 观察者模式 Observer Pattern

> 定义
#
- 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式
#
> 要点
#
- 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体
观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便
#
> 示例
#
![](https://i.imgur.com/9XCVevL.png)
##### 状态模式 State Pattern

> 定义
#
- 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式
#
> 要点
#
- 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码
#
> 示例
#
![](https://i.imgur.com/0YxNUNc.png)
##### 策略模式 Strategy Pattern

> 定义
#
- 策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开，将算法
的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。策略模式定义如下： 策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式
#
> 要点
#
- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有
的算法或行为的情况。策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为
#
> 示例
#
![](https://i.imgur.com/U4vobgy.png)
##### 模板方法模式 Template Method Pattern

> 定义
#
- 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
#
> 要点
#
- 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则
#
> 示例
#
![](https://i.imgur.com/VLThwxf.png)
##### 访问者模式 Visitor Pattern

> 定义
#
- 提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式
#
> 要点
#
- 增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。
破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。
#
> 示例
#
![](https://i.imgur.com/vTreXua.png)

### 总结

> 三类（GOF）：

- 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

- 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

- 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

> 关系

![](https://i.imgur.com/mV15BBS.png)