# Java知识点与设计模式
---

### Java关键字
<table>
	<thead>
		<th>类别</th>
		<th>关键字</th>
		<th>说明</th>
	</thead>
	<tbody>
		<tr>
			<td rowspan="3">访问控制</td>
			<td>private</td>		
			<td>私有的</td>
		</tr>
		<tr>
			<td>protected</td>		
			<td>受保护的</td>
		</tr>
		<tr>
			<td>public</td>		
			<td>公共的</td>
		</tr>
		<tr>
			<td rowspan="13">类、方法和变量修饰符</td>
			<td>abstract</td>		
			<td>声明抽象</td>
		</tr>
		<tr>
			<td>class</td>		
			<td>类</td>
		</tr>
		<tr>
			<td>extends</td>		
			<td>扩充,继承</td>
		</tr>
		<tr>
			<td>final</td>		
			<td>最终值,不可改变的</td>
		</tr>
		<tr>
			<td>implements</td>		
			<td>实现（接口）</td>
		</tr>
		<tr>
			<td>interface</td>		
			<td>接口</td>
		</tr>
		<tr>
			<td>native</td>		
			<td>本地，原生方法（非Java实现）</td>
		</tr>
		<tr>
			<td>new</td>		
			<td>新,创建</td>
		</tr>
		<tr>
			<td>static</td>		
			<td>静态</td>
		</tr>
		<tr>
			<td>strictfp</td>		
			<td>严格,精准</td>
		</tr>
		<tr>
			<td>synchronized</td>		
			<td>线程,同步</td>
		</tr>
		<tr>
			<td>transient</td>		
			<td>短暂</td>
		</tr>
		<tr>
			<td>volatile</td>		
			<td>易失</td>
		</tr>
		<tr>
			<td rowspan="2">程序控制语句</td>
			<td>break、case、continue、default、do、else、for、if、return、switch、while</td>	
			<td>常用</td>
		</tr>
		<tr>
			<td>instanceof</td>		
			<td>实例</td>
		</tr>
		<tr>
			<td>错误处理</td>
			<td>assert、finally、catch、throw、throws、try</td>	
			<td>常用，throws【声明一个异常可能被抛出】，assert【断言表达式是否为真】</td>
		</tr>
		<tr>
			<td>包相关</td>
			<td>import、package</td>	
			<td>常用</td>
		</tr>
		<tr>
			<td>基本类型</td>
			<td>boolean、byte、char、double、float、int、long、short</td>	
			<td>常用</td>
		</tr>
		<tr>
			<td rowspan="3">变量引用</td>
			<td>super</td>	
			<td>父类,超类</td>
		</tr>
		<tr>
			<td>this</td>	
			<td>本类</td>
		</tr>
		<tr>
			<td>void</td>	
			<td>无返回值</td>
		</tr>
		<tr>
			<td rowspan="3">保留关键字</td>
			<td>goto</td>	
			<td>是关键字，但不能使用</td>
		</tr>
		<tr>
			<td>const</td>	
			<td>是关键字，但不能使用</td>
		</tr>
		<tr>
			<td>null</td>	
			<td>空</td>
		</tr>
	</tbody>
</table>

---

### 源文件声明规则

- 一个源文件中只能有一个public类
- 一个源文件可以有多个非public类
- 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。
- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。
- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。
- import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。

---

### 数据类型

####1.值类型

- byte：
	- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
	- 最小值是 -128（-2^7）；
	- 最大值是 127（2^7-1）；
	- 默认值是 0；
	- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
	- 例子：byte a = 100，byte b = -50。
- short：
	- short 数据类型是 16 位、有符号的以二进制补码表示的整数
	- 最小值是 -32768（-2^15）；
	- 最大值是 32767（2^15 1）；
	- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
	- 默认值是 0；
	- 例子：short s = 1000，short r = -20000。
- int：
	- int 数据类型是32位、有符号的以二进制补码表示的整数；
	- 最小值是 -2,147,483,648（-2^31）；
	- 最大值是 2,147,483,647（2^31 1）；
	- 一般地整型变量默认为 int 类型；
	- 默认值是 0 ；
	- 例子：int a = 100000, int b = -200000。
- long：
	- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
	- 最小值是 -9,223,372,036,854,775,808（-2^63）；
	- 最大值是 9,223,372,036,854,775,807（2^63 -1）；
	- 这种类型主要使用在需要比较大整数的系统上；
	- 默认值是 0L；
	- 例子： long a = 100000L，Long b = -200000L。
	- "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。
- float：
	- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
	- float 在储存大型浮点数组的时候可节省内存空间；
	- 默认值是 0.0f；
	- 浮点数不能用来表示精确的值，如货币；
	- 例子：float f1 = 234.5f。
- double：
	- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
	- 浮点数的默认类型为double类型；
	- double类型同样不能表示精确的值，如货币；
	- 默认值是 0.0d；
	- 例子：double d1 = 123.4。
- boolean：
	- boolean数据类型表示一位的信息；
	- 只有两个取值：true 和 false；
	- 这种类型只作为一种标志来记录 true/false 情况；
	- 默认值是 false；
	- 例子：boolean one = true。
- char：
	- char类型是一个单一的 16 位 Unicode 字符；
	- 最小值是 \u0000（即为0）；
	- 最大值是 \uffff（即为65,535）；
	- char 数据类型可以储存任何字符；
	- 例子：char letter = 'A';。
- **实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作**

#### 2.引用类型（与指针类似）

- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。

---

### 类型转换规则

1. 不能对boolean类型进行类型转换。

2. 不能把对象类型转换成不相关类的对象。

3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

4. 转换过程中可能导致溢出或失精度

5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入

6. 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型

---

### 变量

- 局部变量
	1. 局部变量声明在方法、构造方法或者语句块中；
	1. 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
	1. 访问修饰符不能用于局部变量；
	1. 局部变量只在声明它的方法、构造方法或者语句块中可见；
	1. 局部变量是在栈上分配的。
	1. 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 
- 实例变量
	1. 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
	1. 当一个对象被实例化之后，每个实例变量的值就跟着确定；
	1. 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
	1. 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
	1. 实例变量可以声明在使用前或者使用后；
	1. 访问修饰符可以修饰实例变量；
	1. 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
	1. 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
	1. 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。
- 类变量
	1. 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。
	1. 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
	1. 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
	1. 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
	1. 静态变量在第一次被访问时创建，在程序结束时销毁。
	1. 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
	1. 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
	1. 静态变量可以通过：ClassName.VariableName的方式访问。
	1. 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。

---

### 访问控制修饰符
 
1. default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

1. private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类，内部类可以）

1. public : 对所有类可见。使用对象：类、接口、变量、方法
 
1. protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类，内部类可以）。

**注意**

- 父类中声明为 public 的方法在子类中也必须为 public。
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被继承。

### 非访问控制修饰符

- static 修饰符，用来修饰类方法和类变量。

- final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的
	- final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。final 修饰符通常和 static 修饰符一起使用来创建类常量。
	- 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。
	- final 类不能被继承，没有类能够继承 final 类的任何特性。
- abstract 修饰符，用来创建抽象类（抽象类可以包含抽象方法和非抽象方法）和抽象方法。

- synchronized 和 volatile 修饰符，主要用于线程的编程。
	- synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符（public、protected、private、default）。
	- volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
- transient 修饰符
	- 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

---

### 控制语句

- break/continue [label]; 规定标号label必需放在循环之前（意味着循环必需紧跟着标号）
- switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。

---

### 包装类

- Java 会对 -128 ~ 127 的整数进行缓存，所以当定义两个包装类变量初始化值位于 -128 ~ 127 之间时，两个变量使用了同一地址

		Long l1 = 128l;
        Long l2 = 128l;
        System.out.println(l1 == l2);//false！！！
        
        Long l1 = 1l;
        Long l2 = 1l;
        System.out.println(l1 == l2);//true！！！
- 注意 == 与 equals的区别： “==” 它比较的是对象的地址，“equals” 比较的是对象的内容

---

### 继承

- 子类拥有父类非private的属性，方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。
- 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口
- super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
- this关键字：指向自己的引用。
- **如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表，如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。**

---

### 其他知识点

- StringBuilder 与 StringBuffer，处理字符串的速度上前者优于后者，但StringBuilder线程不安全，多线程环境下应使用StringBuffer
- 使用 SimpleDateFormat 格式化日期

		SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss")

- [printf方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头](http://www.runoob.com/java/java-date-time.html)
- 传入可变参数，在方法声明中，在指定参数类型后加一个省略号(...) ，一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明：public static void printMax( double... numbers){}
- Java 允许定义finalize()，它在对象被垃圾收集器析构(回收)之前调用，它可以用来用来清除回收对象
- Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。Error 用来指示运行时环境发生的错误。
![](https://i.imgur.com/UHupPXL.png)
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法；子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
- 重载与重写

	|区别点|重载方法|重写方法|
	|:-|:-|:-|
	|参数列表|必须修改|一定不能修改|
	|返回类型|可以修改|一定不能修改|
	|异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常|
	|访问|可以修改|一定不能做更严格的限制（可以降低限制）|

- **构造方法，类方法（用static修饰的方法）不能声明为抽象方法**